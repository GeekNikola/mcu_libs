# mcu_libs

MIT 开源协议 AGeek （一个极客）开源。
欢迎大家点小星星收藏测试和提交bug。

## 是什么？

mcu_libs 一词双意<br>
My code utils librarys && Microcontroller Unit librarys<br>

mcu_libs 是可运行在单片机的高度可复用的一些C语言代码库的合集。<br>
这些库全是软件应用层较多，尽量不和特定硬件关联。<br>
为了避免我的命名和某些第三方库冲突，我统一把自己写的库加上 "mcu_" 的前缀。<br>

大部分是自己封装的库，也会引入各种开源库，和参考各种通用的结构写法来实现一些功能。<br>

- 注意<br>
(因为window的中文编码默认是GB2312 且众多的开发板和keil例程大多使用GB2312编码<br>
所以库内字符编码采用GB2312，utf-8 中文会显示乱码需要自己转换)<br>


## 为什么？

在嵌入式软件行业工作这么久,自己封装了一些库和结构还有算法。<br>
但是都是在开发各种项目的过程中领悟的,临时应付项目需求。<br>
有时候发现新项目好像可以用到以前旧项目的一些东西,就想把旧项目的一些现成代码拿过来用。<br>
这样我们可以通过以前的经验积累来快速的做开发。<br>
由于没有去整理，结果有时候发现旧项目在需求迭代功能升级过程中已经把代码高度耦合了。<br>
或者是旧项目都找不到，或者有点看不懂了。<br>
(旧项目都已经是屎山代码了，维护比重新开发还难受)。<br>

想单独移植一些精华的通用代码，结果要跑去分析自己以前写的其他烂代码。<br>
看得我都想要不自己重新写一个吧。<br>
(又白白浪费了很多时间，明明之前就有写好的)。<br>

所以,我们应该反思学习后或者项目输出完成后，应该要做些总结和积累.<br>
（通用的代码就应该及时去被封装为一个库，不然白瞎了这些代码积累）<br>

那么为了避免这些情况,我决定把代码的精华集合的通用部分做成库来给自己使用。<br>
而且代码要简洁和通用，最好单独.c和.h来实现一个功能，避免各种耦合。<br>



## 怎么用？

后续会为每个模块写些说明<br>



## 更新进度






- v0.2 添加循环缓存队列 ring buffer <br>

这个比较通用的名字应该是叫环形缓冲区（Ring Buffer）<br>

环形缓存在通讯缓存上特别常用的结构,<br>
比如我们经常把收到的每一个字节数据缓存到数组,<br>
收满了一个数据帧再做处理处理完成后再清0重新缓存。<br>
把一块内存缓存东西最后清除重复使用都是属于缓存区的概念。<br>

我参考一些资料来实现自己的ring buffer<br>
最终为了通用性我决定使用宏来实现泛型，任意类型的模版ring buffer<br>
且宏函数在编译时被展开替换而形成内联，没有函数调用的栈消耗<br>
只是这样就不能调试打断点在封装的宏代码内<br>
调试只能通过修改宏代码来输出信息排查了。<br>


- v0.1 添加tlsf库 

这个是一个内存分配的库，是为了避免单片机使用标准库的动态内存分配下带来内存碎片。<br>
避免因为频繁申请和释放内存后产生的内存碎片导致单片机内存不足跑飞，内存分配是实现其他链式结构的基础。<br>
这个库的可以避免内存碎片同时提供 O(1) 时间复杂度的内存分配和释放操作，<br>
即无论内存的总大小如何，分配和释放操作的时间都是常量级的。<br>
诸如lvgl、LiteOS等都使用了这个动态内存分配算法库<br>
来自开源地址:https://github.com/mattconte/tlsf<br>


